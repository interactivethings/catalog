#!/usr/bin/env node

var fs   = require('fs');
var path = require('path');
var clc  = require('cli-color');
var UglifyJS = require('uglify-js');

var ROOT    = path.join(__dirname, '..');
var VERSION = require("../package.json").version;
var FILES   = process.argv.slice(2);

var newRelease = !versionExists(VERSION);

if (newRelease) {
  fs.mkdir(rpath('dist', VERSION));
} else {
  console.log(clc.yellow.bold("Warning: a distribution for version " + VERSION + " already exists.\nWill update nightly build without touching " + VERSION));
}


FILES.forEach(function(filepath) {
  copyAndExpandFileSync(rpath(filepath), rpath('dist', filepath));

  if (newRelease && filepath.match(/catalog.js/)) {
    var js = fs.readFileSync(rpath(filepath));
    fs.writeFileSync(rpath('dist', VERSION, filepath), js);

    var minpath = filepath.replace(/\.js$/, '.min.js');
    fs.writeFileSync(rpath('dist', VERSION, minpath), minifyJS(js));
  }
});

if (newRelease) {
  console.log(clc.green("Created Catalog version " + VERSION));
} else {
  console.log(clc.green("Updated nightly build"));
}


/* Utils
----------------------------------------------- */

function versionExists(version) {
  return fs.existsSync(rpath('dist', VERSION));
}

function copyAndExpandFileSync(srcPath, destPath) {
  var src = fs.readFileSync(srcPath);
  src = src.toString().replace(/%VERSION%/g, VERSION);
  fs.writeFileSync(destPath, src);
}

function minifyJS(js) {
  return jsBanner() + UglifyJS.minify(js.toString(), {fromString: true}).code;
}

function jsBanner() {
  return "/* Catalog " + VERSION + " */\n";
}

function rpath() {
  var args = Array.prototype.slice.call(arguments);
  return path.join.apply(path, [ROOT].concat(args))
}
